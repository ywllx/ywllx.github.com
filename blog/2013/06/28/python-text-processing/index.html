
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>python文本处理 - 其实很简单</title>
  <meta name="author" content="Fred Yan">

  
  <meta name="description" content="对于脚本语言来说，文本处理任务构成了一个很重要的组成部分。python提供用于文本处理最主要的工具就是字符串——不可改变的字符序列。python提供了很多基于字符串的基本处理方法，掌握这些方法对于处理文本是十分用于的，这里不再详述。我这里主要是总结《python cookbook》 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://ywllx.github.com/blog/2013/06/28/python-text-processing/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="其实很简单" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-39593824-1', 'github.com');
  ga('send', 'pageview');

</script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">其实很简单</a></h1>
  
    <h2>思考是一种美德 坚持是一种行动</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:ywllx.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">博客首页</a></li>
  <li><a href="/blog/archives">文章列表</a></li>
  <li><a href="/blog/about">关于本人</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Python文本处理</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-28T11:45:00-07:00" pubdate data-updated="true">Jun 28<span>th</span>, 2013</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>对于脚本语言来说，文本处理任务构成了一个很重要的组成部分。python提供用于文本处理最主要的工具就是字符串——不可改变的字符序列。python提供了很多基于字符串的基本处理方法，掌握这些方法对于处理文本是十分用于的，这里不再详述。我这里主要是总结《python cookbook》中关于文本处理的几个例子一些内容形成的一个博客。</p>

<!--more-->


<hr />

<h4>每次处理一个字符</h4>

<p>在例子1中，文章提到了如何处理字符串中每个字符的四种基本方法。python实际上并没有一个特别的类型来对应“字符”以区别字符串,要做到每次处理一个字符的方式处理字符串。可以调用内建的<code>list</code>，用字符串作为参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">thelist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">thestring</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者用<code>for</code>语句对该字符串进行循环遍历：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">thestring</span><span class="p">:</span>
</span><span class='line'>  <span class="n">do_something_with</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面可以换成以下用法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">do_something_with</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">thestring</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者用内建的<code>map</code>函数，每次取得一个字符就调用一次处理函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">results</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">do_something</span><span class="p">,</span> <span class="n">thestring</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<h4>测试一个对象是否为字符串</h4>

<p>在python cookbook中提到，许多程序员遇到这个问题的第一反应是采用如下方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">isExactlyAString</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>书中说到这个方法不太好，很多Unicode对象无法通过这个测试，用户自己编写的str的子类也不行，我尝试了下，发现中文字符串还是可以通过这个测试的。书中提到的首先的解决方案是采用如下方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">isAstring</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>但书中接着提到这个方案也有不足，对于python标准库中提到的UserString的模块提供的UserString实例也无能为力，因为它不是从basestring派生的。想检查一个对象行为是否真的像字符串那样，可以采取如下方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">isStringLike</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
</span><span class='line'>  <span class="k">try</span><span class="p">:</span> <span class="n">obj</span> <span class="o">+</span> <span class="s">&#39;&#39;</span>
</span><span class='line'>  <span class="n">excpet</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
</span><span class='line'>  <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>它实用于str，unicode和Usertring，但是比较复杂而且运行比较慢。
这个方法仍有可能不满足的地方，如是作者提到了一个所谓的鸭子判断法：如果它走路像鸭子，而且叫声也像鸭子，那么对于我们的应用而言，便可以认为这个东西就是鸭子。这个方法蛮有意思的，倒有点像做测试，如果我所列出的一大堆测试都过了，那么便可以认为这个程序基本就正确了，可以用了，当然很有可能它还有我们没发现的bug。</p>

<hr />

<h4>合并字符串</h4>

<p>python中如果要把一些小的字符串合并成一个大的字符串，可以使用字符串操作符join，当然我们也可以使用&#8217;+&#8217;操作符也能够将字符串拼接起来，假如pieces是一个字符串列表，那么可以使用以上两种方式进行拼接。
在python中，字符串对象是无法改变的。任何对字符串的操作，包括字符串的拼接，都将产生一个新的字符串对象，而不是修改原有的对象。因此拼接N个字符串将涉及到创建并丢弃N-1个中间结果。当一个序列中包含了很多小的字符串的时候，性能就不得不考虑。在内部使用了 + 或者 += 的循环所需的时间跟需要累加的字符数的平方成正比，因为分配并填充一个大字符串的时间大致正比如该字符串的长度。但是如果我们使用join方法，传入一个字符串序列作为参数，它将返回一个由字符串序列所有子项字符串拼接而成的大字符串，而且这个过程只使用了一个拷贝用于串接所有子项，性能将会得到大大提高。下面是两种实现方法一个简单测试例子，最后执行时间可以看出两者性能差距是很大的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="p"></span><span class="c">#!/usr/bin/env python</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">test1</span><span class="p">(</span><span class="n">pieces</span><span class="p">):</span>
</span><span class='line'>    <span class="n">largeString</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">pieces</span><span class="p">:</span>
</span><span class='line'>        <span class="n">largeString</span> <span class="o">+=</span> <span class="n">piece</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">test2</span><span class="p">(</span><span class="n">pieces</span><span class="p">):</span>
</span><span class='line'>    <span class="n">largeString</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pieces</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">strings1</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">]</span>
</span><span class='line'><span class="n">strings2</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">Timer</span>
</span><span class='line'>    <span class="n">t1</span><span class="o">=</span><span class="n">Timer</span><span class="p">(</span><span class="s">&quot;test1(strings1)&quot;</span><span class="p">,</span> <span class="s">&quot;from __main__ import test1, strings1&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">t2</span><span class="o">=</span><span class="n">Timer</span><span class="p">(</span><span class="s">&quot;test2(strings1)&quot;</span><span class="p">,</span> <span class="s">&quot;from __main__ import test2, strings1&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">t3</span><span class="o">=</span><span class="n">Timer</span><span class="p">(</span><span class="s">&quot;test1(strings2)&quot;</span><span class="p">,</span> <span class="s">&quot;from __main__ import test1, strings2&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">t4</span><span class="o">=</span><span class="n">Timer</span><span class="p">(</span><span class="s">&quot;test2(strings2)&quot;</span><span class="p">,</span> <span class="s">&quot;from __main__ import test2, strings2&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">t1</span><span class="o">.</span><span class="n">timeit</span><span class="p">()</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">t2</span><span class="o">.</span><span class="n">timeit</span><span class="p">()</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">t3</span><span class="o">.</span><span class="n">timeit</span><span class="p">()</span>
</span><span class='line'>    <span class="k">print</span> <span class="n">t4</span><span class="o">.</span><span class="n">timeit</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>上述代码在ubnutu 12.10, python 2.7, CPU为Intel Core P8700环境下执行结果如下：<br/>
8.47422218323<br/>
2.06159615517<br/>
18.8844971657<br/>
4.24623513222<br/></p>

<hr />

<h4>过滤字符串</h4>

<p>给定一个需要保留的字符的集合，构建一个过滤函数，并可将其应用于任何字符串s，函数返回一个s的拷贝，该拷贝只包含指定字符集合中的元素，对于此类问题，不得不提到string对象的下面两个方法：
string.maketrans(from, to)：Return a translation table suitable for passing to translate(), that will map each character in from into the character at the same position in to; from and to must have the same length.</p>

<p>string.translate(s, table[, deletechars])：Delete all characters from s that are in deletechars (if present), and then translate the characters using table, which must be a 256-character string giving the translation for each character value, indexed by its ordinal. If table is None, then only the character deletion step is performed.</p>

<p>当以string.maketrans(&#8221;, &#8221;)方法调用maketrans时，翻译表正好是有256个字符的字符串t。翻译表生成的字符串（忽略不可打印字符）为“!&#8221;#$%&&#8217;()*+,-./:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~”，本质上与ASCII表相对应.</p>
<p>其实调用maketrans函数时，已经完成了转换。例如string.maketrans(&#8216;ABCD&#8217;, &#8216;abcd&#8217;),调用完成后，翻译表生成的包含256个字符的字符串（忽略不可打印字符）为“!&#8221;#$%&&#8217;()*+,-./0123456789:;<=>?@abcdEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~”，该翻译表中的原“ABCD”的位置已被“abcd”替换。</p>
当你把t作为第一个参数传入translate方法时，原字符串中的每一个字符c，在处理完成后都会被翻译成字符t[ord(c)]
而对于translate()简单来说,就是对字符串S移除deletechars包含的字符，然后保留下来的字符按照table里面的字符映射关系映射,这个table必须是a 256-character string giving the translation for each character value, indexed by its ordinal. 这个table正好可以用上面提到的maketrans()生成。
举个例子也许更有说服力：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="p"></span><span class="c">#!/usr/bin/env python</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">string</span>
</span><span class='line'><span class="n">table1</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">table2</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="s">&#39;abcde&#39;</span><span class="p">,</span> <span class="s">&#39;ABCDE&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">table1</span>
</span><span class='line'><span class="k">print</span> <span class="n">table2</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="s">&#39;abcdef-123456&#39;</span>
</span><span class='line'><span class="n">s1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table1</span><span class="p">)</span>
</span><span class='line'><span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table2</span><span class="p">)</span>
</span><span class='line'><span class="n">s3</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table1</span><span class="p">,</span> <span class="s">&#39;abc123&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">s4</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">table2</span><span class="p">,</span> <span class="s">&#39;abc123&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="n">s1</span>
</span><span class='line'><span class="k">print</span> <span class="n">s2</span>
</span><span class='line'><span class="k">print</span> <span class="n">s3</span>
</span><span class='line'><span class="k">print</span> <span class="n">s4</span>
</span></code></pre></td></tr></table></div></figure>
&#8212;
table1与table2不同的地方就在于翻译表中的原“abcde”的位置已被“ABCDE”替换；<br/>
s1,s2,s3,s4打印如下：<br/>
abcdef-123456<br/>
ABCDEf-123456<br/>
def-456<br/>
DEf-456<br/>
s1 = s.translate(table1)           #没做任何变化，输出原字符串<br/>
s2 = s.translate(table2)           #输出ABCDEf-123456 就是将abcd映射为大写的ABCD<br/>
s3 = s.translate(table1, &#8216;abc123&#8217;) #输出def-456， 则是删除了s中的字符abc123<br/>
s4 = s.translate(table2, &#8216;abc123&#8217;) #先把s中的abc123去除了，然后在保留下来的字符中应用table中指定的字符映射关系映射：de -> DE<br/>
还有此方法在python3中好像有变动，具体参考相关python文档了。<br/>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Fred Yan</span></span>

      








  


<time datetime="2013-06-28T11:45:00-07:00" pubdate data-updated="true">Jun 28<span>th</span>, 2013</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/python/'>python</a>
  
</span>


    </p>
    
      
<!-- JiaThis Button BEGIN -->
<div class="jiathis_style_24x24">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_kaixin001"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1357227497148830" charset="utf-8"></script>
<!-- JiaThis Button END -->

<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" id="UYScript" src="http://v1.uyan.cc/js/iframe.js?UYUserId=0" async=""></script>
<!-- UY END -->



    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/06/25/c-pointer/" title="Previous Post: C 指针总结">&laquo; C 指针总结</a>
      
      
        <a class="basic-alignment right" href="/blog/2013/07/01/its-a-dream/" title="Next Post: 梦一场">梦一场 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>最近发表</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/11/16/python-scheduling-events/">python定时执行任务</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/04/linux-cpu-performance/">Liunx CPU 性能分析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/04/for-myself/">送给我自己</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/07/30/sort-algorithms-part2/">深入比较排序算法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/07/29/sort-algorithms-part1/">比较排序算法基本简介</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>文章分类</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/c/'>C (1)</a></li>
<li class='category'><a href='/blog/categories/cpu/'>CPU (1)</a></li>
<li class='category'><a href='/blog/categories/linux/'>Linux (1)</a></li>
<li class='category'><a href='/blog/categories/github/'>github (1)</a></li>
<li class='category'><a href='/blog/categories/life/'>life (2)</a></li>
<li class='category'><a href='/blog/categories/memory/'>memory (1)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (1)</a></li>
<li class='category'><a href='/blog/categories/performance/'>performance (1)</a></li>
<li class='category'><a href='/blog/categories/pointer/'>pointer (1)</a></li>
<li class='category'><a href='/blog/categories/python/'>python (2)</a></li>
<li class='category'><a href='/blog/categories/scheduler/'>scheduler (1)</a></li>
<li class='category'><a href='/blog/categories/sort/'>sort (2)</a></li>

  </ul>
</section>
<section>  
  <ul id="weibo">  
  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=3&speed=0&skin=3&isTitle=1&noborder=1&isWeibo=1&isFans=1&uid=2249429451&verifier=4fc57bc7&dpc=1"></iframe>
  </ul>  
</section>  

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Fred Yan -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
