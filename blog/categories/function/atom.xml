<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: function | 其实很简单]]></title>
  <link href="http://ywllx.github.com/blog/categories/function/atom.xml" rel="self"/>
  <link href="http://ywllx.github.com/"/>
  <updated>2015-01-01T15:46:36+08:00</updated>
  <id>http://ywllx.github.com/</id>
  <author>
    <name><![CDATA[Fred Yan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ primer function]]></title>
    <link href="http://ywllx.github.com/blog/2014/12/31/c-plus-plus-primer-function/"/>
    <updated>2014-12-31T23:16:00+08:00</updated>
    <id>http://ywllx.github.com/blog/2014/12/31/c-plus-plus-primer-function</id>
    <content type="html"><![CDATA[<hr>


<p>不知道不明了不想要,为什么我的心,明明是想靠近,却孤单到黎明;不知道不明了不想要,为什么我的心,那爱情的绮丽,总是在孤单里,再把我的最好的爱给你。喜欢一个人，她却不喜欢你，的确是一件很痛苦的事情啊！其实觉得挺可笑的，根本未曾拥有，何来失去，也许正如对她说的，我努力过，坚持过，无论结果如何，不需要后悔了！</p>


<p>最近一直在借助C++ primer这本书，打算全面复习下C++的基础知识，这篇博客主要是这本书上摘录下来的介绍C++函数的一些觉得有用的知识点，自己看看</p>


<p></hr></p>

<hr>


<p><em>1，函数的形参为函数提供了已命名的局部存储空间，是一个变量，作用域为整个函数。实参出现在函数调用中，是一个表达式，进行函数调用时，由传递给函数的实参对形参进行初始化。
</em>2，函数的形参表可以为空，但不能省略
<em>3，C++是一种静态强类型语言，对于每次的函数调用，编译时都会检验其实参，对于每一个实参，其类型都必须与对应的形参类型相同，或具有可被转换为该形参类型的类型。
</em>4，形参的初始化与变量的初始化一样，如果形参具有非引用类型，则复制实参的值，如果形参为引用类型，则它只是实参的别名。
<em>5，函数的形参是指针时，此时将复制实参指针，如果函数将新指针赋值给形参，主调函数使用的实参指针的值没有改变，如果函数形参是非const类型的指针，则函数可以通过指针实现赋值，改变指针所指向对象的值（实参指针不会改变，但指向的值改变）
</em>6，使用引用形参，函数可以直接访问实参对象，无需复制它，尤其是使用const引用可以避免复制（例如const string &amp;s1）
<em>7，应该将不需要修改的引用形参定义为const引用，普通的非const引用形参在使用时不灵活，既不能用const对象初始化，也不能使用直接传入的字面值或产生右值的表达式实参初始化。
</em>8，函数千万不要返回局部对象的引用和指针，因为一旦函数结束，局部对象将会被释放
<em>9，如果有一个形参具有默认实参，那么它后面所有的形参都必须有默认实参，默认实参只能用来替换函数调用缺少的尾部实参。
</em>10，static局部对象，当定义静态局部对象的函数结束时，静态局部对象不会撤销
<em>11，inline函数应该在头文件中定义，在头文件中加入或者修改inline函数时，使用了该头文件的所有源文件都必须重新编译。
</em>12，类的函数原型必须在类中定义，但是，函数体既可以在类中定义也可以在类外定义。编译器隐式地将在类内定义的成员函数当作inline函数。
<em>13，每个成员函数都有一个额外的，隐含的形参this，在调用成员函数时，形参this初始化为调用函数的对象的地址
</em>14，在类成员函数声明的形参表后面的const改变了隐含的this形参的类型，在调用对象成员函数时，隐含的this形参将是一个指向对象的const类指针，用这种方式使用的const的函数称为常量成员函数，由于this是指向const对象的指针，const成员函数不能修改调用该函数的对象。
<em>15，const对象，指向const对象的指针或引用只能用于调用其const成员函数，如果尝试用它们来调用非const成员函数，则是错误的。
</em>16，类必须编写一个成员那就是构造函数，通过构造函数来初始化其数据成员。
<em>17，构造函数是特殊的成员函数，和类同名，没有返回类型，一个类可以有多个构造函数，每个构造函数必须有与其它构造函数不同数目或类型的形参。
</em>18，构造函数必须在类中声明，但是可以在类中或者类外定义。如果没有为一个类显示定义任何构造函数，编译器将自动为这个类生成默认的构造函数。
<em>19，编译器创建的默认构造函数称为合成的默认构造函数（synthesized default constructor），对于含有内置类型或复合类型成员的类，通常应该定义他们自己的默认构造函数初始化这些成员。
</em>20，Sales_item(): units_sold(0), revenue(0.0) { }，构造函数的初始化列表示例，每个成员后面是在圆括号里的初始值，多个成员的初始化值用逗号分隔。
<em>21，函数重载匹配的三种结果：(1),找到最佳匹配，(2)，找不到形参与实参匹配的函数原型，这样编译器将报错，(3)，存在多个与实参匹配的类型，但没有一个明显的最佳选择，这时调用具有二义性
</em>22，重载确定三步骤：(1)，候选函数，必须与被调用函数同名，且在调用点上，声明可见，(2)，选择可行函数，可行函数必须满足两个条件：第一，函数的形参与该调用的实参个数相同，第二，每一个实参的类型必须与对应形参类型匹配，或者隐式地转换为对应的形参类型。（如果函数具有默认实参，则调用该函数时，所用的实参可能比实际参数要的少，默认实参也是实参，在函数匹配过程中，它的处理方式与其他实参一样）(3)，寻找最佳匹配，(4)，含有多个形参的重载确定，(1)，其每个实参的匹配不劣于其它可行函数需要的匹配。(2)，至少有一个实参的匹配优于其他可行函数提供的匹配。（实际应用过程中，应尽量避免强制转换，否则意味着设计的形参不合理。
<em>23，在使用枚举类型形参的重载函数时，由于不同枚举类型的枚举常量值不同，在函数重载确定过程中，不同的枚举类型会具有完全不同的行为。其枚举成员决定了它们提升的类型，而所提升的类型依赖于机器。
</em>24，仅当形参是引用或指针时，形参是否为const才对重载有影响。
<em>25，函数指针是指向函数而非对象的指针，指向某个特定的类型，函数类型由其返回类型以及形参表确定，而与函数名无关
</em>26，函数指针只能通过同类型的函数或函数指针或0值常量表达式进行初始化或赋值。
*27，如果指向函数的指针没有初始化，或者具有0值，则该指针不能在函数调用中使用，只有当指针已经初始化，或被赋值为指向某个函数，方能安全地用来调用函数。</p>
]]></content>
  </entry>
  
</feed>
